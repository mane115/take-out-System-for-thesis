"use strict"
var request = require("request");
var getErrMesg = require("./util").getErrMesg;
var accessToken = null;
var tokenExpiredDate = null;
var param = global.atworkCfg;
var tokenStatus = "notInited";
/*
	token的几种状态:

	notInited	未初始化
	pending		正在申请
	inited 		完成初始化
	expired 	等待重新申请
	fail 		申请token失败次数过多
	retried		失败重试中
*/


//设计为可以使用promise对象
var applyForToken = function(success, fail) {
	var arg = {
		uri: param.apiServer + "/token",
		encoding: "utf-8",
		json: true,
		headers: {
			"Content-type": "application/json"
		},
		body: {
			grant_type: "client_credentials",
			scope: "app",
			tenant_id: param.tenement_id,
			client_id: param.client_id,
			client_secret: param.client_secret
		}
	};
	var handleServerResponse = function(error, httpResponse, body) {
		var networkErr = function(error) {
			console.error("请求apiServer出错", error);
			fail(getErrMesg(90001));
		};
		var parseBody = function(body) {
			if (typeof body === "string") body = JSON.parse(body);
			console.info("从apiServer返回内容为：", body);
			if (body.status === 0) {
				console.info("获取到的token是：", body.result);
				success(body.result);
			} else {
				console.error("获取token失败：", body);
				fail(getErrMesg(body.status));
			}
		};
		if (error || httpResponse.statusCode !== 200) {
			networkErr(error || httpResponse.statusCode);
		} else {
			parseBody(body);
		}
	};
	console.info("申请token的参数是：", arg);
	request.post(arg, handleServerResponse);
};

var isTokenExpired = function() {
	if (!accessToken) {
		console.warn("当前没有token");
		return true;
	} else if ((tokenExpiredDate - new Date().getTime() < param.advanceTime)) {
		console.warn("token即将过期");
		tokenStatus = "expired";
		return true;
	} else {
		console.warn("使用缓存token,token过期时间为:", new Date(tokenExpiredDate), tokenExpiredDate);
		return false;
	}
};

var resetTokenStatus = function() {
	tokenStatus = "notInited";
}
var refreshToken = function(success, fail, max) {
	var maxRetries = max === undefined ? param.maxRetries : max;
	var doRefreshToken = function() {
		var next = function(data) {
			accessToken = data.access_token;
			tokenExpiredDate = data.expire_time;
			tokenStatus = "inited";
			success(accessToken);
		};
		var retry = function() {
			console.warn("上轮申请失败，正在重新申请token，剩余次数是", maxRetries);
			tokenStatus = "retry";
			refreshToken(success, fail, --maxRetries)
		};
		var runtimeException = function(e) {
			console.error("运行时异常", e);
			fail(getErrMesg(90002));
		};
		console.info("准备申请新token，目前状态是", tokenStatus);
		tokenStatus = "pending";
		new Promise(applyForToken).then(next, retry).catch(runtimeException); //唯一的异常已在此处捕捉，调用者不会直接面对这一层的异常
	};
	var waitForToken = function() {
		console.info("有其它任务在申请token，无需重复申请，等待token就绪，目前状态是", tokenStatus);
		var tryAgain = function() {
			refreshToken(success, fail, maxRetries)
		}
		setTimeout(tryAgain, 1500);
	};
	var failTooMuchTimes = function() {
		console.error("申请token失败重试达到最大数次，将暂停token申请10秒，函数状态在10秒后复原");
		tokenStatus = "fail";
		fail(getErrMesg(90003));
		setTimeout(resetTokenStatus, 10000);
	};

	var postponeApplyForToken = function() {
		console.error("之前申请token失败重试次数过多，将暂停申请token一段时间，这是为了防止api server的拒绝服务");
		fail(getErrMesg(90006));
	}

	var useCache = function() {
		console.info("等待的token返回，使用缓存");
		success(accessToken);
	}
	if (tokenStatus === "fail") { //之前的任务申请token失败超过三次，或者自己申请token失败超过三次
		postponeApplyForToken();
	} else if (maxRetries < 1) {
		failTooMuchTimes();
	} else if (tokenStatus === "pending") { //已经有任务正在申请token
		waitForToken();
	} else if (tokenStatus === "inited") { //之前的任务申请token完成
		useCache();
	} else {
		doRefreshToken(); //说明第一次申请token，或者是重新申请token
	}
};

var getAccessToken = function() {
	if (isTokenExpired()) {
		return new Promise(refreshToken);
	} else {
		return Promise.resolve(accessToken);
	}

};

var resetToken = function() {
	accessToken = null;
	tokenStatus = "notInited";
	console.info("销毁当前token");
	return getAccessToken();
};

var synGetToken = function() {
	return accessToken;
}

module.exports = {
	getAccessToken: getAccessToken,
	resetToken: resetToken,
	synGetToken: synGetToken
}