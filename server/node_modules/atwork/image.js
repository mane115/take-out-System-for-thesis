"use strict"
var url = require("url")
var request = require("request");
var getErrMesg = require("./util").getErrMesg;
var tokenModules = require("./token");
var api = require("./api-server");
var param = global.atworkCfg;

var setExpireTime = function(res) {
	var liveTime = 2592000000; //缓存一个月内有效
	var expires = new Date();
	expires.setTime(expires.getTime() + liveTime);
	res.setHeader("Expires", expires.toUTCString());
	res.setHeader("Cache-Control", "max-age=" + liveTime);
	return res;
}
var getImage = function(mediaID, res) {
	var downloadImg = function(success, fail) {
		setExpireTime(res);
		var redirectStream = function(token) {
			/*以前的做法是node server读下来再做转发，
			这个实在是不合理，现在的做法是直接重定向
			隐藏的bug是如果token not found的话，无法自动再发起请求*/

			res.writeHead(301, {
				Location: url.resolve(param.apiServer, "media", mediaID, `?access_token=${token}`)
			})
			res.end();
		};
		tokenModules.getAccessToken().then(redirectStream).catch(error);
	}
	return new Promise(downloadImg);
}

var uploadImage = function(stream) {
	var uploadData = function(success, fail) {
		var error = function(e) {
			fail(e);
		};
		var upload = function(token) {
			var callbacks = {
				success: success,
				fail: fail
			};
			var formData = {
				expire_millis: 4102444800000,
				checksum: "南无观世音菩萨摩诃萨",
				width: 1600,
				height: 1200,
				size: 204800,
				thumbnail_width: 400,
				thumbnail_height: 300,
				thumbnail_save: "true",
				media: stream
			}
			var arg = {
				method: "POST",
				uri: url.resolve(param.apiServer, `media/compress?access_token=${token}`),
				formData: formData
			};
			console.log("上传图片的url是", arg.uri);
			api.getSendRequestFunc(arg, callbacks, param.maxRetries)();
		};
		tokenModules.getAccessToken().then(upload).catch(error);
	};
	return new Promise(uploadData);
}

module.exports = {
	getImage: getImage,
	uploadImage: uploadImage
}